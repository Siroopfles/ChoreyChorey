rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // ORGANIZATIONS
    match /organizations/{orgId} {
      // Anyone authenticated can create an organization if they set themselves as the owner.
      allow create: if isAuthenticated() && request.resource.data.ownerId == request.auth.uid;

      // Org owner can read, update, or delete their organization.
      // Reading for members will be handled by team logic.
      allow read, update, delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
    }

    // USERS
    match /users/{userId} {
      allow read: if isAuthenticated();

      // A user can create their own document.
      allow create: if isOwner(userId);

      // A user can update their own document under specific conditions.
      allow update: if isAuthenticated() && isOwner(userId) && (
        // SCENARIO 1: Creating a new organization.
        // This is a batch write that creates an org and updates the user.
        (
          // organizationIds array must increase by exactly one.
          request.resource.data.organizationIds.size() == request.data.organizationIds.size() + 1 &&
          // Get the ID of the newly added organization.
          let newOrgId = request.resource.data.organizationIds.diff(request.data.organizationIds).added_values()[0];
          // currentOrganizationId must be set to this new ID.
          request.resource.data.currentOrganizationId == newOrgId &&
          // Look at the organization document as it will exist *after* this batch write.
          let newOrgData = getAfter(/databases/$(database)/documents/organizations/$(newOrgId)).data;
          // The user must be the owner of this new organization.
          newOrgData.ownerId == request.auth.uid &&
          // Ensure other critical fields are not changed in the same transaction.
          request.resource.data.name == request.data.name &&
          request.resource.data.email == request.data.email &&
          request.resource.data.avatar == request.data.avatar
        )
        ||
        // SCENARIO 2: Updating profile info (name, avatar) or switching organizations.
        (
          // organizationIds must not change in this scenario.
          request.resource.data.organizationIds == request.data.organizationIds &&
          // If currentOrganizationId changes, it must be one of the user's existing orgs.
          (request.resource.data.currentOrganizationId == request.data.currentOrganizationId || request.resource.data.currentOrganizationId in request.resource.data.organizationIds)
        )
      );
    }
    
    // TEAMS
    match /teams/{teamId} {
      function getOrg(orgId) {
        return get(/databases/$(database)/documents/organizations/$(orgId));
      }
      function isOrgOwner(orgId) {
        return getOrg(orgId).data.ownerId == request.auth.uid;
      }

      // Org owner can read, create, update, delete teams in their org.
      allow read, delete, update: if isAuthenticated() && isOrgOwner(resource.data.organizationId);
      allow create: if isAuthenticated() && isOrgOwner(request.resource.data.organizationId);
    }
    
    // NOTIFICATIONS
    match /notifications/{notificationId} {
      // User can read/update their own notifications
      allow read, update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      // Anyone authenticated can create a notification (the server action validates who it's for)
      allow create: if isAuthenticated();
    }
    
    // TASKS
    match /tasks/{taskId} {
      function isOrgMember(orgId) {
        // Simplified: only owner can access tasks. This should be expanded with team logic.
        return get(/databases/$(database)/documents/organizations/$(orgId)).data.ownerId == request.auth.uid;
      }
      allow read, write: if isAuthenticated() && isOrgMember(resource.data.organizationId);
    }
  }
}
